# Discord DM â€“ 2025-11-20

[2025-11-20 10:37 AM] rsulfuratus: i have been working on revamping my session note processing pipeline - with codex it is way faster and i'm cleaning up my old code and restructuring things. 
    
    the basic framework that I'm trying to implement is something like this:
    raw audio ->` raw transcript `[ASR, diarization]`
    raw transcript ->` clean transcript `[code, maybe gpt via API]`
    clean transcript ->` bullet points `[code, gpt API]`
    bullet points ->` narrative, timeline `[LLM + manual cleanup]`
    bullet points, narrative, timeline ->` session manifest `[codex/copilot + manual cleanup]`
    bullet points, narrative, session manifest->` final session note `[code]`
    
    the logic here is that there is basically part 1, which is turning a recording into a set of bullet points; and part 2, which is processing a narrative/timeline/bullet points to make a session manifest capturing details, and then auto-generating a formatted session note from that (plus narrative)
    
    so for something like our main taelgar games, which are nearly all recorded, the process is run some code to automatically produce a clean transcript and bullet points, then either paste those into an LLM chatbot to generate a narrative and a timeline or write the narrative/timeline yourself, then go to codex or copilot (something with context) to generate a session manifest from a jscon schema, and then finally run a session note generator script that formats the session note. 
    
    but, for something like addermarch or cleenseau, which are not recorded, it is just as easy to start with the narrative/timeline in whatever raw format you have, and then generate the manifest and the formatted session note
    
    i'm still working on a bunch of pieces but i pushed a session manifest template (in _templates/json) and some auto-generated (via codex) session manifests for some addermarch and cleenseau notes
[2025-11-20 10:38 AM] rsulfuratus: i'm kind of bouncing around between debugging ASR/diarization for the taelgar in person recordings and working on the "session manifest + narrative + timeline" ->` final session note code
[2025-11-20 10:46 AM] rsulfuratus: though i also need to get back to the transcript ->` bullet points for the chasm session notes
[2025-11-20 10:46 AM] rsulfuratus: in any case, not sure if this is useful to you but i pushed some sample cleenseau session manifest jsons
[2025-11-20 10:47 AM] rsulfuratus: these are generated with codex but copilot would presumably also work, just pointing at the template and the session note
[2025-11-20 10:49 AM] rsulfuratus: i haven't written the code yet to format things but the idea is you could pick a format style, and then autobuild the final note from the manifest and the narrative. it might use light ai to format lists into sentences - though actually this could be easier to do not in code, just using codex/copilot to update the draft session note to match a format template
[2025-11-20 10:51 AM] rsulfuratus: anyway, i'm continuing to mess around when i have time; feel free to ignore but to the extent this is useful to you for cleenseau session notes / session information, lmk
[2025-11-20 08:29 PM] rsulfuratus: pushed some chasm session 1 stuff to _sessions/chasm-001
[2025-11-20 08:30 PM] rsulfuratus: no proper session note yet but mostly cleaned transcript and bullet point summarie
[2025-11-20 08:30 PM] rsulfuratus: still figuring out the best way to automate this step but for now just relying on codex, which actually works reasonably well
[2025-11-20 08:42 PM] rsulfuratus: the one thing that would be quite useful is if you could fill in the timeline at the front of summary.md with background events leading up to the start of the adventure
[2025-11-20 09:15 PM] rsulfuratus: pushed a session note. probably could use a bit of cleaning up although likely not worth editing the bullet points section unless you see facts that are wrong or something
[2025-11-20 09:16 PM] Deciusmus: is it worth adding notes to the summary.md or should I just edit the session note itself
[2025-11-20 09:16 PM] rsulfuratus: no just edit the session note at this point
[2025-11-20 09:18 PM] rsulfuratus: at some point i might reorganize session processing files, but for now i'm keeping all the stuff that i edit/generate with codex in _sessions (except the json files for session manifests which for now live next to the session note), and all the pre-codex stuff elsewhere
[2025-11-20 09:40 PM] Deciusmus: huh I could use a secret filter all of a sudden ðŸ™‚
[2025-11-20 09:41 PM] Deciusmus: do you have the notes on how yours works?
[2025-11-20 09:47 PM] rsulfuratus: yeah it is easy but you would probably need to use a different secrets code
    
    i have a python script that has an encode and decode mode. in encode mode it replaces `%%`SECRET (text) `%%` with `%%`SECRET`[1]``%%` (or 2, 3, 4, etc for each secret in the file), and writes the encoded text to .secrets/fileName.1 (or .2, .3 etc)
    
    in decode mode it finds `%%`SECRET`[1]``%%` and replaces it with the contents of .secrets/fileName.1
    
    then in my .gitattributes, I have:
    `*`.md filter=remove-secrets
    
    and in .git/config i have:
    
    `[filter "remove-secrets"]`
        clean = python .scripts/filter-secrets.py save %f .secrets
        smudge = python .scripts/filter-secrets.py restore %f .secrets
    
    which runs clean on push and smudge on pull
[2025-11-20 09:48 PM] rsulfuratus: `%f` is path/to/file
[2025-11-20 09:51 PM] rsulfuratus: this is the python - the only thing you'd need to change is anywhere where it says SECRET would need to be a different string so my code won't match your secrets and vice versa
Attachment (filter-secrets.py):
```py
## python program to remove secret text 

import re
import os
import sys

def process_matches(matches, mode, input_str, filename, secret_storage_root):
 
     # Initialize a counter for the match number
    match_num = 0

    # Iterate over the matches
    for match in matches:
        # Extract the contents of the first group in the tuple
        secret = match[0] or match[1] or match[2]

        # Increment the match number
        match_num += 1

        #print(f"Match: %s" % (match,), file=sys.stderr)
        #print("Secret: \n------\n" + secret + "\n----\n", file=sys.stderr)

        if mode == "save":
            # We are saving the secrets

            #print("Saving secrets", file=sys.stderr)
            # Construct the secret storage filename
            secret_storage_filename = os.path.join(secret_storage_root, filename + "." + str(match_num))

            # Write the secret to the secret storage file
            with open(secret_storage_filename, "w") as f:
                f.write(secret)

            # Replace the secret in the input string with the placeholder text
            if (match[2]):
               # print("Got yaml secret", file=sys.stderr)
###secret[1][" + str(match_num) + "]", input_str, flags=re.DOTALL)
            elif (match[0]): 
                input_str = re.sub(r"%%SECRET[2]%%", "%%SECRET[3]%%", input_str, flags=re.DOTALL)
            else: 
                input_str = re.sub(r"%%SECRET[4]%%SECRET[3]%%", input_str, flags=re.DOTALL)

        elif mode == "restore":
            # We are restoring the secrets

            # Construct the secret storage filename
            secret_storage_filename = os.path.join(secret_storage_root, filename + "." + str(match_num))

            # Read the secret from the secret storage file
            with open(secret_storage_filename, "r") as f:
                restored_secret = f.read()

            # Replace the placeholder text in the input string with the secret
            if (match[0] or match[1]): 
                restored_secret = "%%SECRET[5]%%"
                input_str = re.sub(r"%%SECRET[6]%%", restored_secret, input_str, flags=re.DOTALL)
            else:
###secret[7]"
                input_str = re.sub(r"\#\#\#secret\[" + str(match_num) + r"\]", restored_secret, input_str, flags=re.DOTALL)

    # Return the modified input string
    return input_str

## sys.argv[1] is save or restore
## sys.argv[2] is file name
## sys.argv[3] is secrets directory

## secret_storage_root has the base path for the secrets direct
secret_storage_root = sys.argv[3]

## filename has the input filename
filename = os.path.basename(sys.argv[2])

# Read the contents of standard input as a string
input_str = sys.stdin.read()

# Use a regular expression to find all substrings that match the pattern "%% ... %%"
# or that start with "%%" and continue to the end of the input string
pattern = r"%%SECRET[8]%%|%%SECRET[9]%%
# Discord DM ‚Äì 2023-12-03

[2023-12-03 08:15 AM] rsulfuratus: the automatic link text for location chains that switch type is very nice. however, it is often the case you don't want link text for the first element in a chain. more specifically, you might want link text for a location if it is "current" but not if it is "origin"
[2023-12-03 08:22 AM] rsulfuratus: e.g., this is incorrect:
    Originally from: in Ainumarya, Central Highlands Region
[2023-12-03 08:22 AM] rsulfuratus: but this is correct (if I change page date)
    Based in Ainumarya, Central Highlands Region
[2023-12-03 08:22 AM] Deciusmus: Yeah that was on my list but I didn‚Äôt get to it. It‚Äôs because the lack of q in the format specifier is now ignored
[2023-12-03 08:23 AM] Deciusmus: It should mean ‚Äúskip the first link text‚Äù
[2023-12-03 08:30 AM] rsulfuratus: right. i was looking at trying to do that, but getFormattedString doesn't know what part of the chain it is
[2023-12-03 08:31 AM] Deciusmus: Its slightly non-obvious, basically you need to set the default format string to `<name>` if the format doesn‚Äôt contain q
[2023-12-03 08:32 AM] Deciusmus: But actually it‚Äôs more than that, what I wanted to do was split the filter and the format.
[2023-12-03 08:32 AM] Deciusmus: And move the link text into name manager as what gets generated for q
[2023-12-03 08:32 AM] Deciusmus: And then pass the format string to the name
[2023-12-03 08:32 AM] rsulfuratus: I lookeda that too, but #getDescriptionForThisPiece doesn't have the format string
[2023-12-03 08:32 AM] Deciusmus: But I haven‚Äôt quite thought it all through
[2023-12-03 08:33 AM] rsulfuratus: need a string object
[2023-12-03 08:33 AM] rsulfuratus: üòâ
[2023-12-03 08:42 AM] Deciusmus: do you think it would be annoying to have a format specifier like:
    
    ````<current:a;b;c>````
    
    a: filter
    b: formatter for first part
    c: formatter for all parts
[2023-12-03 08:44 AM] Deciusmus: so ````<current:2r;Q;x>````
    
    would mean:
    
    1. filter using 2r
    2. apply the Q format to the first piece
    3. apply the x format to all pieces
[2023-12-03 08:44 AM] Deciusmus: the "format" would be the format specifier for the name part, if not specified
[2023-12-03 08:45 AM] rsulfuratus: I think the format specifier is getting overloaded already
[2023-12-03 08:45 AM] Deciusmus: Would you prefer a wHomeFilter ?
[2023-12-03 08:45 AM] Deciusmus: or wHome being a complex type?
[2023-12-03 08:45 AM] Deciusmus: { wHome: { format: } { filter: } }
[2023-12-03 08:46 AM] rsulfuratus: no, I think that is worse
[2023-12-03 08:47 AM] rsulfuratus: I would probably do something like `<format:current:filter>`
[2023-12-03 08:48 AM] rsulfuratus: although actually that might be annoying too
[2023-12-03 08:48 AM] rsulfuratus: hmm
[2023-12-03 08:48 AM] Deciusmus: so ````<Q:current:2r>```` ? that seems worse
[2023-12-03 08:48 AM] rsulfuratus: I'm trying to avoid `<current:;;x>`
[2023-12-03 08:48 AM] Deciusmus: so there is an argument for wHomeFilter etc
[2023-12-03 08:49 AM] Deciusmus: because actually, you *never* overload that on the page
[2023-12-03 08:49 AM] Deciusmus: because realistically you set the filter on the whereabout line
[2023-12-03 08:49 AM] Deciusmus: not the page level
[2023-12-03 08:49 AM] Deciusmus: it is really the "default start filter for this type"
[2023-12-03 08:49 AM] Deciusmus: it could even just be wDefaultStartFilter
[2023-12-03 08:50 AM] rsulfuratus: but not being able to generically filter `<loc>` strings will be super annoying in general, for anything other than specific whereabouts lines
[2023-12-03 08:50 AM] rsulfuratus: e.g., for campaignInfo lines
[2023-12-03 08:51 AM] rsulfuratus: which are often repetitive and so might want different filters
[2023-12-03 08:56 AM] Deciusmus: I dunno, looking at the current data the only place it is used is to cause one of Dee Wildcloaks lines to not show "Thirsty Scholar, Chardon, Chardonian Empire"
[2023-12-03 08:56 AM] Deciusmus: (but to just show "Thirsty Scholar, Chardon")
[2023-12-03 08:57 AM] rsulfuratus: but the current state is not reflective of the final stage, because things are in flux enough that I usually don't invest time in formatting
[2023-12-03 08:57 AM] Deciusmus: I actually there there is a different problem, which is that you don't want to be constantly repeating the same location information in th header
[2023-12-03 08:58 AM] rsulfuratus: I usually fiddle with one or two pages to see how things work
[2023-12-03 08:58 AM] Deciusmus: that is, it isn't so much that you want a specific different filter for met by party as you don't want to see the same string repeated over and over again
[2023-12-03 09:00 AM] rsulfuratus: sure, but some kind of filter on repetition is going to be way trickier than just giving direct control over location filters for each line
[2023-12-03 09:00 AM] Deciusmus: sure, but I don't think there is any good way to do locationfilters for each line other than
    
    ````<current:filter;format>````
[2023-12-03 09:01 AM] rsulfuratus: just because we are running out of letters?
[2023-12-03 09:01 AM] Deciusmus: oh, you want to keep them intermingled?
[2023-12-03 09:01 AM] Deciusmus: The problem is that I want the startfilter to override the *filter* but not the *format*
[2023-12-03 09:02 AM] Deciusmus: and I need to know which part of the format should apply to *all* pieces vs just the *first* piece
[2023-12-03 09:02 AM] Deciusmus: I could just split
[2023-12-03 09:02 AM] Deciusmus: i.e. take
    
    3rqa
    
    the code knows that r and 3 are filter and q and a are format
[2023-12-03 09:02 AM] Deciusmus: so it could just built 2 values from the one string
[2023-12-03 09:02 AM] rsulfuratus: yeah
[2023-12-03 09:02 AM] Deciusmus: but that is kinda annoying and inprecise to me
[2023-12-03 09:03 AM] Deciusmus: and to me it feels harder to read
[2023-12-03 09:03 AM] rsulfuratus: `<current:2rP;Uq>` is nice to me; `<current:;q>` is not
[2023-12-03 09:04 AM] rsulfuratus: so what I would do is write a format parser function that splits on `;` and then deconvoltes if there is no `;`
[2023-12-03 09:05 AM] rsulfuratus: and possibly fixes errors, e.g. if you have `<current:q;2>` it fixes it
[2023-12-03 09:13 AM] Deciusmus: eh, see writing a format parser in C# sounds like fun; Javascript not so much
[2023-12-03 09:13 AM] Deciusmus: I was just going to make regex groups for the parts, which is tolerable
[2023-12-03 09:14 AM] rsulfuratus: your refusal to engage with regexs is kind of breaking down
[2023-12-03 09:14 AM] Deciusmus: I know
[2023-12-03 09:14 AM] Deciusmus: its sad
[2023-12-03 09:15 AM] Deciusmus: handling the simple case of
    
    ````<current:q>````
    
    is pretty easy
[2023-12-03 09:15 AM] rsulfuratus: i will try to get chatgpt to write a format parser
[2023-12-03 09:15 AM] Deciusmus: heh
[2023-12-03 09:15 AM] rsulfuratus: the question is what an ideal format parser would return
[2023-12-03 09:15 AM] Deciusmus: { format: x, filter: y }
[2023-12-03 09:16 AM] Deciusmus: parseFormat(input, validFilterChars, validFormatChars)
    
    returns
    
    { format: x, filter: y }
    
    or undefined if the string cant be parsed
[2023-12-03 09:46 AM] rsulfuratus: here you go:
    ```javascript
    function parseTokenString(input, filterChars, formatChars) {
    
        // Initial structure of the result
        let result = {
            token: null,
            filter: null,
            format: null
        };
    
        // Check if the input is in the expected format
        if (input.startsWith("`<") && input.endsWith(">`")) {
            let innerContent = input.slice(1, -1).split(":");
            
            if (innerContent.length === 1) {
                // Case for only token
                result.token = innerContent`[0]`;
            } else if (innerContent.length === 2) {
                // Case for token with filter and format
                result.token = innerContent`[0]`;
                let initialFormat = innerContent`[1]`.split(";");
    
                // Separate filter and format based on allowable characters
                let filter = "";
                let format = "";
    
                for (let formatString of initialFormat) {
                    for (let char of formatString) {
                        if (filterChars.includes(char)) filter += char;
                        if (formatChars.includes(char)) format += char;
                    }
                }
    
                result.filter = filter;
                result.format = format;
            }
        }
    
        return result;
    }
    
    ```
[2023-12-03 09:53 AM] rsulfuratus: not guaranteed to be bug-free
[2023-12-03 09:53 AM] rsulfuratus: I'm not fluent enough with javascript to see at a glance
[2023-12-03 10:25 AM] rsulfuratus: I have 2 hours while kate and kids are at church, i'm messing around with a new token parser structure. fine if it doesn't end up being useful. i pushed a basic, not working and very incomplete (mostly auto-generated by copilot) template as tokenParser.js
[2023-12-03 10:34 AM] Deciusmus: I just pushed my version
[2023-12-03 10:37 AM] Deciusmus: I'm going to go play Zelda with Z fora while, but it is a slightly hacky bit of logic that
    
    (a) implements in the location chain the idea of a separate "filter", "first format string", "all format string"
    (b) syntax is ````<current:filter;firstFormat;allFormat>````
    (c) if ````<current:x>```` is specified, and x is a valid format string, it will be treated as firstFormat rather than filter
    (d) the default format is 'q' but 'Q' overrides (i.e. if you have both q and Q you do not get link text)
[2023-12-03 11:11 AM] rsulfuratus: here is what I am doing:
    // a full formatfilter string is defined as filter;format;firstformat
    // if the string is only two parts, it is filter+firstformat;format
    // if the string is only one part, it is filter+firstformat
[2023-12-03 11:12 AM] rsulfuratus: so Qp is interpreted as filter: p, firstformat: Q, format: null
[2023-12-03 11:12 AM] rsulfuratus: Qp;q is interpreted as filter: p, firstformat: Q, format: q (which is equivalent to p;q;Q)
[2023-12-03 11:13 AM] rsulfuratus: which is reversed from yours because that way if you have "p;q" and decide you need a separate first format you can add ";Q", or if you just want to specify firstformat you can do: Q
[2023-12-03 11:31 AM] Deciusmus: Sure
[2023-12-03 11:32 AM] rsulfuratus: my hope is that even if my general token parser class isn't useful, at least the parseToken function might be. it also returns mindepth and maxdepth, so your result is:
    ```
            let result = {
                token: null,
                filter: null,
                format: null,
                firstformat: null,
                mindepth: 1,
                maxdepth: null
            };
    ```
[2023-12-03 11:33 AM] Deciusmus: That seems helpful
[2023-12-03 11:33 AM] Deciusmus: It would probably be nice for the location stuff to take that instead of the various params
[2023-12-03 11:33 AM] rsulfuratus: exactly
[2023-12-03 11:35 AM] rsulfuratus: ultimately the idea is you have a format string like "Arbitrary text where `<event>` happened to `<person>`, at `<name>`", you pass it to a parser that splits it and passes each chunk to another parser, that returns either the raw text or the formatted string for that token
[2023-12-03 11:36 AM] rsulfuratus: so each `<token>` has a parsed token object, and then each token needs a method to get the information given metadata. those are already written, so it just about reorganizing how things are passed around
[2023-12-03 11:36 AM] rsulfuratus: but ideally would allow e.g. reusing depth filters for affiliation chains if we want to do that
[2023-12-03 11:37 AM] rsulfuratus: e.g. `<primary:2>`
[2023-12-03 12:56 PM] Deciusmus: btw, I was thinking about your "metadata" thoughts doc, I think there is a lot of good stuff there. I think it might be worth reconsidering exactly what a header should be. For example, I'm not sure that for most random npcs I actually care when they are born, but I do care how old they are if known, and if they are alive or dead.
[2023-12-03 01:01 PM] Deciusmus: for example, here's a random minor NPC I made up:
    
    # Avelina Smith
    >``[!info]`+ Biographical Info
    >` A Highlander [[Humans|human]] (she/her)
    >` Born DR 1673 (47 years old)
    
    An important smith and leader of the metalworking community of [[Cleenseau]]. She trained with dwarves in her youth.
[2023-12-03 01:01 PM] Deciusmus: anyway, more later, we are going to get lunch
[2023-12-03 02:12 PM] rsulfuratus: fiddling amongst other things. here is the basic structure i'm working with:
    
    pass a string to getDisplayString, which then parses out token and format with parseToken
    
    then pass parsed token object to getFormattedToken, which checks through a bunch of cases to find the right way to (a) set the value of token.token, and (b) format that value based on the token object format parameters
[2023-12-03 02:14 PM] rsulfuratus: for example, dates all get the "date" formatter applied, which for now is just DateManager.normalizeDate(value).display, but could in the future support eg a cy/dr format string option, or a full date (Jan 1, 1749) vs short date (1749), or other format options
[2023-12-03 02:15 PM] rsulfuratus: strings get "string" format, which is basically NameManager.getName(string), although there are probably some quirks to smooth out
[2023-12-03 02:15 PM] rsulfuratus: eventually the hope is a generic "chain" format that can built location or affiliation or other thing chains, that just needs to know what to follow
[2023-12-03 02:16 PM] rsulfuratus: but for now locchain is its own thing
[2023-12-03 02:16 PM] rsulfuratus: anyway, it is all in tokenParser, you can take a look
[2023-12-03 03:55 PM] Deciusmus: I'm messing around with a standardized name object
[2023-12-03 03:55 PM] Deciusmus: it isn't quite what you were talking about, but..
[2023-12-03 03:56 PM] rsulfuratus: i just pushed a few more Token Parser updates
[2023-12-03 03:57 PM] rsulfuratus: the basic logic is:
    ```
       // This class is responsible for parsing tokens and returning formatted strings
        // There are two main functions:
        // 1. parseDisplayString: takes a display string with words and tokens ("This is a `<token>`, print it."), 
        //      replaces each token with a formatted version, and returns a formatted string
        // 2. getFormattedToken: takes a token string (`<token:format>`) and returns a formatted string
        // Both functions take a string as the first argument, a file object as the second argument, and a targetDate as the third argument
    ```
[2023-12-03 03:58 PM] rsulfuratus: so one thing that would be very useful is something like normalizeDate for normalizeName, that could return the info needed to build a formatted name (which mostly needs to manage linking)
[2023-12-03 03:59 PM] rsulfuratus: but it is probably better if the normalize name function doesn't do the formatting itself, it just builds the name
[2023-12-03 04:14 PM] Deciusmus: I don't think it is quite right the way you are trying to stick all the formatting inside the parser
[2023-12-03 04:14 PM] Deciusmus: I would have a formatName function in the name manager that takes a name object and format specifier and returns a formatted string
[2023-12-03 04:14 PM] Deciusmus: one of the challenges, for names in particular, is that most of the input for a name has to be overrideable
[2023-12-03 04:15 PM] rsulfuratus: well, that's fine too, you just pass token.format to NameManager.formatName
[2023-12-03 04:15 PM] Deciusmus: to generate a name, you need:
    * the "target"
    * a potential alias
    * a potential link text override
    * potential article override (not yet in use)
[2023-12-03 04:15 PM] Deciusmus: plus you need the source page, to get the right link text
[2023-12-03 04:16 PM] Deciusmus: so the "getNameObject" API takes:
    
    * a string (target)
    * a string (sourcePageType)
    * override object that has { alias, linkText, article }
[2023-12-03 04:16 PM] rsulfuratus: I don't think that is quite right
[2023-12-03 04:16 PM] rsulfuratus: you only need a source page in chains, right?
[2023-12-03 04:16 PM] Deciusmus: anytime you want link text
[2023-12-03 04:17 PM] Deciusmus: that is, anytime you are generating a name for a relationship between page A & page B
[2023-12-03 04:17 PM] Deciusmus: you don't always have a relationship
[2023-12-03 04:17 PM] rsulfuratus: but that is always a chain
[2023-12-03 04:17 PM] Deciusmus: person in campaign info
[2023-12-03 04:17 PM] Deciusmus: affiliations
[2023-12-03 04:18 PM] Deciusmus: both examples of "relationship names" that are not part of a chain
[2023-12-03 04:18 PM] rsulfuratus: campaign info and affiliations are complicated
[2023-12-03 04:18 PM] Deciusmus: I thought about using `<linktext>` as a separate piece of data, but it doesn't work as nicely as :q / :Q
[2023-12-03 04:18 PM] Deciusmus: because you want to control whether/when it shows up
[2023-12-03 04:19 PM] Deciusmus: so logically, "`<person:format>`" should actually be generated by getting the name of the target page, using the current page as the sourceType
[2023-12-03 04:19 PM] rsulfuratus: right, so that is what I would consider a chain
[2023-12-03 04:20 PM] Deciusmus: sure, it is a chain of lengt 1
[2023-12-03 04:20 PM] rsulfuratus: the idea is you call the internal #formatToken recursively
[2023-12-03 04:21 PM] rsulfuratus: so a token `<person>` becomes:
    `<linktext>``<name>` 
    with source = current, target = "person"
[2023-12-03 04:21 PM] rsulfuratus: same for location chains, you walk up the chain and each piece just generates a new token to call #formatToken
[2023-12-03 04:22 PM] Deciusmus: sure but I don't think linkText is/should be a separate token
[2023-12-03 04:22 PM] Deciusmus: too hard to determine if/when it appears
[2023-12-03 04:22 PM] Deciusmus: "`<person:xxx>`" should become `<name:xxx>` in the context of the person page
[2023-12-03 04:23 PM] Deciusmus: i.e. you call getName passing the value of person and the source page as te current page
[2023-12-03 04:24 PM] rsulfuratus: right
[2023-12-03 04:24 PM] rsulfuratus: haven't quite figured out how you have link text coded
[2023-12-03 04:24 PM] rsulfuratus: but that would be fine too
[2023-12-03 04:25 PM] rsulfuratus: the thing I'm not currently sure of is where the override information comes from
[2023-12-03 04:26 PM] rsulfuratus: is it always calculable from a prior step in the recursion? or does the getFormattedToken need to take an override object itself
[2023-12-03 04:27 PM] Deciusmus: curently string formatter takes it
[2023-12-03 04:27 PM] Deciusmus: I believe that will stay true
[2023-12-03 04:27 PM] rsulfuratus: but where does string formatter get it?
[2023-12-03 04:27 PM] Deciusmus: its a parameter
[2023-12-03 04:28 PM] Deciusmus: it comes from whoever is formatting the string
[2023-12-03 04:28 PM] Deciusmus: in the current code, it comes from the location manager, when it decides to format a string to represent the current whereabout, it knows the overrides because they are coming from whereabouts.linkText
[2023-12-03 04:28 PM] Deciusmus: or whereabouts.alias
[2023-12-03 04:29 PM] Deciusmus: separately, string formatter in some cases knows it itself, i.e. when it is formatting "species" and sees a "specieAlias"
[2023-12-03 04:29 PM] rsulfuratus: but all that is already being passed via the file object, it is just a matter of where it is calculated
[2023-12-03 04:29 PM] Deciusmus: or typeof and sees a typeOfAlias
[2023-12-03 04:30 PM] Deciusmus: the whereabout isn't, it is the next level down the chain
[2023-12-03 04:30 PM] rsulfuratus: well more precisely it is calculatable from the metadata
[2023-12-03 04:30 PM] Deciusmus: well, everything is calculated from some piece of metadata somewhere
[2023-12-03 04:30 PM] Deciusmus: but you dont want the token / string code to know about whereabouts
[2023-12-03 04:30 PM] Deciusmus: i.e. it shouldn't access whereabout.linkText
[2023-12-03 04:31 PM] rsulfuratus: well, it has to, because if your token is `<current>` you need to get wb.current
[2023-12-03 04:32 PM] Deciusmus: but it shouldn't know what to do with a whereabout
[2023-12-03 04:32 PM] rsulfuratus: no, all it knows to do is to pass it to locationChainFormatter or whatever
[2023-12-03 04:32 PM] Deciusmus: it gets wb.current and then askes the location manager to do something with it
[2023-12-03 04:32 PM] Deciusmus: the location manager then in turn decides it needs to format a string, so askes the string formatter to format `<name:q>`
[2023-12-03 04:32 PM] Deciusmus: etc
[2023-12-03 04:32 PM] rsulfuratus: right
[2023-12-03 04:33 PM] rsulfuratus: but the getDisplayString never needs to get any input data besides a string with tokens, a file to start at, and possibly a targetDate
[2023-12-03 04:34 PM] rsulfuratus: display string parses out tokens, token formatter takes each token and calls the correct manager to handle it, and then returns the formatted string to getDisplayString
[2023-12-03 04:34 PM] rsulfuratus: anyway we are about to leave
[2023-12-03 04:34 PM] rsulfuratus: more later
[2023-12-03 04:35 PM] Deciusmus: That's wrong, but yes, we are also leaving
[2023-12-03 09:41 PM] rsulfuratus: Might fiddle a bit more - you should push what you‚Äôve been doing even if it isn‚Äôt fully functional yet
[2023-12-03 09:55 PM] Deciusmus: pushed
[2023-12-03 09:55 PM] Deciusmus: it gets articles wrong at the moment
[2023-12-03 10:05 PM] Deciusmus: plus a couple of bugfixes


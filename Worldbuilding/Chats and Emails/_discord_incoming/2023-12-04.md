# Discord DM â€“ 2023-12-04

[2023-12-04 01:10 AM] rsulfuratus: couldn't sleep so I stayed up too late fiddling around. i think i finally understood your string parsing setup.
    
    the Token Parser class should be (mostly) able to replace the StringManager class. you can call it either with a display string ("Display this `<name:format>`"), an unparsed token (`<name:format>`) , or a parsed token object. 
    
    the key advantage IMO is it separates token parsing into (a) getting the format string, and (b) figuring out the correct manager to call to format the particular token. 
    
    all the Token Parser functions take:
    (a) input (either a display string, a token, or a token object, depending on the function)
    (b) a file (equivalent to file in getFormattedString)
    (c) a targetDate (the date you want the token formatted at)
    (d) an overrides object
    
    The overrides object is generally just appended to metadata, so it can be used to supply any format-line-specific metadata (like person/met for campaign info).  but there are some special terms used for NameManager and others, see the code
[2023-12-04 01:11 AM] rsulfuratus: there are still some bugs for sure and doesn't necessarily work well with everything else (e.g. locationManager) but at least for me separating format parsing and "what do I do with this token" feels a lot easier to understand
[2023-12-04 12:15 PM] Deciusmus: I think in general it makes sense but it drops a number of features from string formatter, i.e. the ability to do stuff only on the first item and have prefixes and suffixies
[2023-12-04 02:49 PM] rsulfuratus: mostly been super busy but just pushed a fix for prefixes and suffixes
[2023-12-04 02:49 PM] Deciusmus: ah, hrm. I spent a while at lunch rewriting the whole thing to work
[2023-12-04 02:49 PM] Deciusmus: then I got busy and didn't get a chance to push it
[2023-12-04 02:50 PM] rsulfuratus: oops
[2023-12-04 02:50 PM] Deciusmus: I think I pretty much had stringmanager 100% replaced
[2023-12-04 02:50 PM] Deciusmus: the most useful bit was distinguishing between "name" tokens and "casing" tokens which solved my problem of strings coming up as "A born..."
[2023-12-04 02:51 PM] rsulfuratus: parse-tokens has my fixes but yours may be cleaner
[2023-12-04 02:52 PM] Deciusmus: yah, I just wrote a giant regex with https://regexr.com/ that matches everything perfectly to groups
[2023-12-04 02:52 PM] rsulfuratus: mine is https://regex101.com/
[2023-12-04 02:52 PM] Deciusmus: // this is a complicated regex, but basically it is 6 groups:
            //      first, prefix: contained in (), any letters or spaces
            //      second, token: letters only
            //      third, filter: digit-digit, plus filter options
            //      fourth, first item format string: the standard format string options. Can be separated from the filter with an optional semi-colon
            //      fifth, the all item format string: the standard format string options. Must be separated from the filter with a semi colon
            //      sixth, suffix: contained in (), any letters or spaces
            const regexp = /`<(\(`[()a-zA-Z-:*\s]`+\))?(`[a-zA-Z]`+):?(`[0-9]`*`[-]`?`[0-9]`*`[RrPpLlIiOoFf!]`*)?;?(`[UutsaAnyxqQ]`+)?;?(`[UutsaAnyxqQ]`+)?(\(`[()a-zA-Z-:*\s]`+\))?>`/g;
    
            if (((input || '').match(regexp) || `[]`).length !== 1) {
                return null;
            }
    
            let match = regexp.exec(input)
            if (match) {
                token.prefix = match`[1]` ?? ""
                token.token = match`[2]` ?? ""
                token.filter = match`[3]` ?? ""
                token.format = match`[4]` ?? ""
                token.chainFormat = match`[5]` ?? match`[4]` ?? ""
                token.suffix = match`[6]` ?? ""
            }
[2023-12-04 02:53 PM] Deciusmus: that formated weird:
    
    ```
        // this is a complicated regex, but basically it is 6 groups:
            //      first, prefix: contained in (), any letters or spaces
            //      second, token: letters only
            //      third, filter: digit-digit, plus filter options
            //      fourth, first item format string: the standard format string options. Can be separated from the filter with an optional semi-colon
            //      fifth, the all item format string: the standard format string options. Must be separated from the filter with a semi colon
            //      sixth, suffix: contained in (), any letters or spaces
            const regexp = /`<(\(`[()a-zA-Z-:*\s]`+\))?(`[a-zA-Z]`+):?(`[0-9]`*`[-]`?`[0-9]`*`[RrPpLlIiOoFf!]`*)?;?(`[UutsaAnyxqQ]`+)?;?(`[UutsaAnyxqQ]`+)?(\(`[()a-zA-Z-:*\s]`+\))?>`/g;
    
            if (((input || '').match(regexp) || `[]`).length !== 1) {
                return null;
            }
    
            let match = regexp.exec(input)
            if (match) {
                token.prefix = match`[1]` ?? ""
                token.token = match`[2]` ?? ""
                token.filter = match`[3]` ?? ""
                token.format = match`[4]` ?? ""
                token.chainFormat = match`[5]` ?? match`[4]` ?? ""
                token.suffix = match`[6]` ?? ""
            }
    ````
[2023-12-04 02:53 PM] Deciusmus: it handles filters vs formats nicely
[2023-12-04 02:53 PM] Deciusmus: i.e
[2023-12-04 02:53 PM] rsulfuratus: this works too: `<(\(.*?\))?(`[a-zA-Z]`+):?(`[^:()\s`<>`]`+?)?(\(.*?\))?>`
[2023-12-04 02:53 PM] rsulfuratus: ```
    `<(\(.*?\))?(`[a-zA-Z]`+):?(`[^:()\s`<>`]`+?)?(\(.*?\))?>`
    ```
[2023-12-04 02:53 PM] rsulfuratus: but you have to separately parse the filter
[2023-12-04 02:54 PM] Deciusmus: ````<token:filterformat>```` works
    
    as does
    
    ````<token:filter;format>````
    
    but you can't do
    
    ````<token:formatfilter>````
[2023-12-04 02:54 PM] Deciusmus: but I think that's fine
[2023-12-04 02:55 PM] Deciusmus: I also renamed "first format" to format and chainFormat to the remainder.
[2023-12-04 02:55 PM] rsulfuratus: my version is:
    ``<token:a>``: a is interpreted as a "all format" + filter
    ``<token:a;b>``: a is interpreted as "all format"  + filter; b is first format
[2023-12-04 02:56 PM] Deciusmus: so the "expanded" syntax is
    
    ````<token:filter;format;chainFormat>````
    
    where chainFormat applies to *everything* in a chain; format applies to the first part only (which, if it isn't a chain, is the same as everything)
[2023-12-04 02:56 PM] Deciusmus: yeah mine is basically the same but it inverts "all" vs "first" format
[2023-12-04 02:56 PM] Deciusmus: with the special case of, if you apply a format but no chain format it is both
[2023-12-04 02:57 PM] Deciusmus: i.e. `<token:filter;q>` applies to the whole chain
[2023-12-04 02:57 PM] Deciusmus: I guess it would be better to say:
    
    ````<token:filter;format>````
    
    where the ```filter;``` is optional is the expected format, and if specified, applies to everything
[2023-12-04 02:58 PM] Deciusmus: if you need to differentiate "first" from "rest", you need to say:
    
    ````<token:filter;rest;first>````
[2023-12-04 02:58 PM] Deciusmus: (where again, the `filter;` is optional)
[2023-12-04 02:58 PM] rsulfuratus: I think it is easier to have `<token:string>` parse string as either "filter + format" or "filter + chainFormat" (in your terms), and then have `<token:string;string2>` parse string2 as the other one
[2023-12-04 02:59 PM] rsulfuratus: isn't that way simpler?
[2023-12-04 02:59 PM] rsulfuratus: it is just a question of whether `<token:qr>` should apply q as "format" or "chainFormat" and I have no strong opinions about that
[2023-12-04 02:59 PM] Deciusmus: well, the regex I wrote breaks apart the filter automaticlly
[2023-12-04 02:59 PM] Deciusmus: you can't intermix
[2023-12-04 02:59 PM] Deciusmus: i.e.
    
    1-2qr is not valid
[2023-12-04 02:59 PM] Deciusmus: because the 1-2r is a filter and the q is a format
[2023-12-04 03:00 PM] rsulfuratus: well then my regex is better ðŸ˜‰
[2023-12-04 03:00 PM] Deciusmus: but I did that on purpose so I could do:
    
    token.format = group
    token.fiilter = group
[2023-12-04 03:01 PM] rsulfuratus: but that is not hard to parse, as long as format and filter chars are distinct
[2023-12-04 03:01 PM] rsulfuratus: you only ever need to parse it once, so why not just separately parse the filter?
[2023-12-04 03:01 PM] rsulfuratus: the formatfilter string
[2023-12-04 03:01 PM] rsulfuratus: I mean
[2023-12-04 03:02 PM] Deciusmus: eh, I don't have strong feelings. but it seems very trivial benefit to be able to write 2qr vs having to write 2rq
[2023-12-04 03:02 PM] rsulfuratus: the format and filter codes are hard enough to remember, having the order be critical just makes more fragile and harder to use
[2023-12-04 03:03 PM] Deciusmus: and it makes the groups easier, i.e. x;y naturally "knows" whether it is a filter and a format or two formats
[2023-12-04 03:04 PM] Deciusmus: and filterformat;other also can automatially parse into the right group sets
[2023-12-04 03:04 PM] rsulfuratus: well I was going for ease of writing. if I have a party meeting line with `<current:2q>` and I decide I don't want the regions, I don't want to have to remember I have to insert r after 2, I just want to add r. numbers have to go first is enough to remember
[2023-12-04 03:04 PM] Deciusmus: see, I think having 2q is bad practice. it should be 2;q
[2023-12-04 03:05 PM] Deciusmus: that's much easier for me to see and understand
[2023-12-04 03:05 PM] Deciusmus: 2farlP buries the a
[2023-12-04 03:05 PM] Deciusmus: you want to encourage 2frlP;a
[2023-12-04 03:06 PM] rsulfuratus: sure, but should 2farlP just not work? I guess I prefer tolerance in this case
[2023-12-04 03:07 PM] Deciusmus: I'm not against it, just found it much simpler to not support it
[2023-12-04 03:08 PM] rsulfuratus: my code to parse the filter string should work, it just required some tweaking to properly support prefixes and suffixes
[2023-12-04 03:09 PM] rsulfuratus: it is easy to modify to support whatever a, a;b, and a;b;c should mean
[2023-12-04 03:09 PM] rsulfuratus: i picked the option that seemed to generate the most correct text with current metadata display defaults
[2023-12-04 03:10 PM] rsulfuratus: anyway I have to get Nathaniel to martial arts but I'm not doing anything from 4-5 roughly so if you push your changes I can at least attempt to rebase my token-parser branch
[2023-12-04 03:10 PM] Deciusmus: rebase will be hopeless, I deleted all that code
[2023-12-04 03:11 PM] Deciusmus: but if you want to restore the token parsing, to your way I won't object although keep my regex as a comment at least
[2023-12-04 03:11 PM] Deciusmus: the main things are
    (a) don't split out the depths; that is a whereabouts specific thing and I don't think it should be assumed that it is a property of a token
    (b) you need to return the prefix and suffix
[2023-12-04 03:12 PM] rsulfuratus: why do we assume that depth is a whereabouts specific thing? the reason to split it out is that any chain could theoretically have a depth filter, e.g. at some point we might want to allow a depth filter for affiliation chains or anything else
[2023-12-04 03:13 PM] Deciusmus: but filters might not always be for chains
[2023-12-04 03:14 PM] Deciusmus: and I don't think it adds value
[2023-12-04 03:14 PM] Deciusmus: with the current setup it is *much* simpler for the thing that takes a filter to handle the filter; it is really an opaque blob
[2023-12-04 03:15 PM] Deciusmus: arguably the syntax should be something like
    
    `<token:`[filter]`format>`
[2023-12-04 03:15 PM] Deciusmus: where filter is literally an opaque blob
[2023-12-04 03:15 PM] Deciusmus: then you could do stuff like
    
    `<affiliations:`[type=primary]`>`
[2023-12-04 03:16 PM] Deciusmus: for now that seems too complex
[2023-12-04 03:16 PM] Deciusmus: but having the token parser try to "understand" the filter doesn't seem worthwhile
[2023-12-04 03:20 PM] rsulfuratus: Fair enough. The concept of what a filter is supposed to be is pretty ambiguous arm
[2023-12-04 03:21 PM] rsulfuratus: But opaque blob is fine
[2023-12-04 05:31 PM] rsulfuratus: I am currently trying to re-understand token parser. I will open a pull request tonight to merge this into main, and you are welcome to comment at that point, but i'm probably not going to try to merge any new changes from new-whereabouts at this point. 
    
    While I appreciate that some of your ideas here are better than mine, the whole thing I enjoy about this is figuring out how to implement things and get them to work. I realize that I am not the fastest coder but I think it is okay if this isn't done in 24 hours. 
    
    If you really feel like this is too much your project to let anyone else fiddle around with I'll find another coding project, but I'm enjoying this and it is useful to learn from your experience. It just isn't fun for you to just reimplement all my code while I'm still trying to get it to work in the first place
[2023-12-04 05:32 PM] rsulfuratus: there is a reason i've been doing this all on an isolated branch
[2023-12-04 06:04 PM] Deciusmus: I totally get that... I'm actually kinda ready to be done mucking about with Javascript as much as I have been... but I want to be able to quickly add new stuff when I want it here. It's tough to know how to balance that. Do I just add stuff to the old way?
[2023-12-04 06:06 PM] Deciusmus: I don't really intend/want to trample on your coding exercise at all, I'm just not sure how to move this all forward if we end up with two parallel development tracks
[2023-12-04 06:07 PM] rsulfuratus: I guess I'm suggesting maybe it doesn't have to move forward super-quickly?
[2023-12-04 06:08 PM] rsulfuratus: I mean I get you want to mess around too, but I'd suggest either just spending less time on it or messing around with different parts instead of the same thing at once
[2023-12-04 06:08 PM] rsulfuratus: e.g. there is plenty to do with event handling, for example
[2023-12-04 06:09 PM] rsulfuratus: in general of course having well-defined APIs would help let us both mess around with interacting parts of the code at the same time
[2023-12-04 06:10 PM] rsulfuratus: but also i'm happy to port stuff from the old way to the new way, as long as things don't change SO fast that I can never catch up without spending 8 hours a day on it
[2023-12-04 06:10 PM] rsulfuratus: for example with the token parser, most of what i was doing was almost totally independent of your name object stuff
[2023-12-04 06:11 PM] Deciusmus: yeah, I mean, the token parser was a pretty close-to-drop-in replacement for string formatter
[2023-12-04 06:11 PM] Deciusmus: it just made solving certain problems a lot easier
[2023-12-04 06:11 PM] Deciusmus: so I didn't want to wait for it to be ready ðŸ™‚
[2023-12-04 06:14 PM] rsulfuratus: anyway kate is cooking dinner tonight so i'm working on it now and will hopefully push something cleaned up soon, although there are still probably some bugfixes
[2023-12-04 06:18 PM] rsulfuratus: it doesn't help when I keep running into weird things like javascript considers an empty array to be truthy (in python you wouldn't need complicated things like `if (value && (!Array.isArray(value) || value.length >` 0)) `)
[2023-12-04 06:30 PM] rsulfuratus: your whereabout stuff is clever
[2023-12-04 06:31 PM] Deciusmus: same pattern works for affiliations
[2023-12-04 06:31 PM] Deciusmus: way nicer
[2023-12-04 06:31 PM] Deciusmus: Haven't figured out how to make it work for multi-line strings, but I will leave that for your project ðŸ™‚
[2023-12-04 06:33 PM] rsulfuratus: what is your opinion on the following:
    I currently have the #getFormattedName to either take a name object, or value is not a name object, look for a property in metadata called "`<token>`Alias" and if that exists, build a name object with the value of that as the alias
[2023-12-04 06:34 PM] Deciusmus: dinner is ready so afk for a while. That special casing works but you need to be careful about generic values vs names
[2023-12-04 06:35 PM] Deciusmus: that is, take a look at the difference between "casing" and "name"
[2023-12-04 06:35 PM] rsulfuratus: this is not for generic metadata, just for things processed by "name" formatting
[2023-12-04 06:35 PM] Deciusmus: yeah it is probably a good general rule
[2023-12-04 06:35 PM] Deciusmus: actually could solve a bunch of issues with ancestry
[2023-12-04 06:35 PM] Deciusmus: i.e. 
    
    ancestry: Sembara
    ancestryAlias: western Sembaran
[2023-12-04 06:35 PM] Deciusmus: or whatevr
[2023-12-04 06:35 PM] rsulfuratus: yeah just means that that is a general rule
[2023-12-04 06:36 PM] Deciusmus: reduces the special case for species and typeOf
[2023-12-04 06:36 PM] rsulfuratus: if a token is processed by the name formatter, then "tokenAlias" becomes alias
[2023-12-04 06:36 PM] Deciusmus: yeah makes sense (with the exception of name itself)
[2023-12-04 06:36 PM] rsulfuratus: but default is still casing
[2023-12-04 06:37 PM] rsulfuratus: if value is a name object then it just gets passed to name manager
[2023-12-04 08:19 PM] Deciusmus: left a few comments on your pr;
[2023-12-04 08:25 PM] Deciusmus: I pushed a fix for the infinite loop
[2023-12-04 08:25 PM] Deciusmus: that was in my whereabouts chain code
[2023-12-04 08:25 PM] rsulfuratus: great
[2023-12-04 08:41 PM] Deciusmus: there are a couple of other bugs, do you want me to fix them?
[2023-12-04 08:42 PM] Deciusmus: aliases don't work correctly and the "is first" logic is wrong
[2023-12-04 08:42 PM] rsulfuratus: i'm trying to fix the isFirst logic which I can't quite track down
[2023-12-04 08:42 PM] rsulfuratus: please fix aliases
[2023-12-04 08:47 PM] Deciusmus: any objection to moving the alias check to the main switch statement, so that getFormattedName always has a name object
[2023-12-04 08:48 PM] rsulfuratus: I didn't put it there, because then you have to repeat it for typeof and species as well
[2023-12-04 08:48 PM] Deciusmus: i.e. something like this:
    
    ```
                case "ancestry":
                case "subtypeof":
                case "subspecies":
                case "species":
                case "person":
                    let valueFromMetadata = this.#getParameterCaseInsensitive(metadata, token.token)
                    let possibleAliasKey = token.token + "alias"
                    let alias = this.#getParameterCaseInsensitive(metadata, possibleAliasKey)
    ```
[2023-12-04 08:48 PM] rsulfuratus: ah yeah that is good
[2023-12-04 08:49 PM] Deciusmus: I am also tempted to resplit typeof and maintype
[2023-12-04 08:49 PM] Deciusmus: although maybe there is no sense in which you'd ever have a page with species and typeOf?
[2023-12-04 08:50 PM] rsulfuratus: Probably okay to split it
[2023-12-04 08:50 PM] Deciusmus: right now it is impossible to get the typeof a page that has a specieis
[2023-12-04 08:51 PM] rsulfuratus: yeah I merged them originally because it didn't occur to me you could have just a bunch of cascading cases into the same processing but with that setup the benefit of merging is less clear actually
[2023-12-04 08:56 PM] rsulfuratus: Re: "This will break files that have an actual name attribute in metadata that doesnâ€™t match the filename. (Ie some of the Cleenseau people who non-ascii names). We should only use the name instead of the filename is the name is a normalized name object)"
[2023-12-04 09:00 PM] rsulfuratus: The reason I did it this way is that I want "BÃ©atrix of Cleenseau" to use metadata.name (which is "BÃ©atrix of Cleenseau") instead of file.name (which is Beatrix of Cleenseau) for the main H1 of the note. But, I think that if you pass Beatrix of Cleenseau to the name formatter it should return BÃ©atrix of Cleenseau anyway, yes?
[2023-12-04 09:03 PM] Deciusmus: getNameObject expects to get either
    (a) a filename
    (b) an unlinkable string
[2023-12-04 09:03 PM] Deciusmus: basically the way getNameObject works is that first, it tries to find the file for the target
[2023-12-04 09:03 PM] Deciusmus: and then it calculates the articles and stuff from the file
[2023-12-04 09:04 PM] Deciusmus: if it can't find the file, it makes some stuff up best it can
[2023-12-04 09:04 PM] Deciusmus: you can see the bug if you go to Beatrix and delete the aliases
[2023-12-04 09:04 PM] Deciusmus: her name will become The BÃ©atrix of Cleenseau
[2023-12-04 09:04 PM] rsulfuratus: right, so there is no reason to pass metadata.name because you are going to end up with that anyway (via the file Beatrix of Cleenseau)
[2023-12-04 09:04 PM] Deciusmus: right
[2023-12-04 09:05 PM] Deciusmus: HOWEVER, various things that want to override name set (currently) overrides.name
[2023-12-04 09:05 PM] rsulfuratus: yeah, I was catching that in the formatter function but it seems like your way is better to just format it here
[2023-12-04 09:05 PM] rsulfuratus: anyway, I'm afk for a bit
[2023-12-04 09:05 PM] rsulfuratus: feel free to fix any of the name/alias bugs
[2023-12-04 09:06 PM] rsulfuratus: and deconvolute any merged tokens
[2023-12-04 09:07 PM] rsulfuratus: i am still tracking down a few small bugs and then will deal with the formatfilter string parsing, which I think you are right, you can either pass a single string that is filter+format (but no chain format), or a separated string that is either filter;format;chain
    filter;format
    format;chain
[2023-12-04 09:08 PM] rsulfuratus: that is relatively straightforward to fix just requires a bit of fiddling
[2023-12-04 09:13 PM] Deciusmus: ok, I pushed a fix to the name stuff
[2023-12-04 09:19 PM] Deciusmus: not going to do much more tonight


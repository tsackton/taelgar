# Templates Documentation

This file contains documentation for the usage of the templates within the templates folder. Currrently, there are three major complex templates for management of headers and metadata.

### generate-header
This template generates a header block based on the metadata within the frontmatter of the file. It creates a custom block for the entity types it is aware of. To ease export to HTML. the header block this template generates is mostly static. Currently the only dynamic pieces are the age and birth and death years of NPCs and the age, birth, death, and regnal years of Rules. These dynamic elements use dataview. In the future additional dynamic elements might be added.

Each dynamic element used by generate-header must also be implemented in convert_markdown.py in order to enable seemless export to HTML.

This template requires the `dViewPath` to be set in your `taelgarConfig.json`. 

### regenerate-header
This template is expected to be run on files with a type already defined. It will not modify or insert metadata and does not make use of the `metadata.json` or `taelgarConfig.json` files. The primary usage of this is to delete the header generated by generate-header and reinsert the generate-header template. This allows a quick refresh of a header after changing metadata.

This template will delete data from your file, and uses raw read/write APIs from the Obsidian Vault API. It is recommended that you save your file before running this in order to ensure that the template is always reading the newest data from disk.

The header is defined as the set of lines between the end of the YAML frontmatter and the first blank line.

This template makes no use of configuration. 

### process-note
This template is a generic processing template designed to process either an empty note, a partially completed note (either with minimal metadata or with no metadata), or a note with complete metadata and:

* Determine the note type, or if not possible, prompt for it
* Prompt for a name, if run in a file named Untitled. Note that this will detect name clashes and enforce a unique name for the file across the vault.
* Ensure that all expected metadata elements are present and insert missing ones, using folder-based default vaules if configured
* Insert or update the header block

This is intended to be run in new files and would be suitable to be auto-run for all new files. It depends on both the `taelgarConfig.json` file to determine default values for metadata elements and the shared `metadata.json` to determine the set of metadata elements and initial tags to insert in a file.

The processing flow is:
1. Determine the type of the file by matching on path or from the frontmatter
2. If the file type cannot be determined via path matching, prompt for a file type
3. Determine the name of the file, either from the filename, or if the filename is Untitled, by prompting
4. Find the default tags and metadata for the file type and insert into the frontmatter
5. Delete the header material and reinsert the header template. Note that if the file has no frontmatter when the template is run, the header is inserted before the full contents of the file and no deletion occurs

#### Configuration Rules

The configuration file has a single property, `types`, which is an array of type objects. Each type object has:
* A string type name, i.e. NPC, Item, Building
* An array of strings, frontmatter, which is a list of the frontmatter to insert for this type
* An array of strings, initial tags, which is a list of tags to set for this type if the type has no tags
* An array of strings, typeFolderNames, which is a list of regexes that will be applied to the full relative path of the file to auto-determine the type. Note that order matters, i.e. the code uses the first match. So if you have a match on People and one on PCs, make sure the PCs is listed first in the file as People is also in the PC 

Note that the JavaScript function used by the template allows for a parameter for setting the type, so instead of making complex regex it is also possible to just define a ruler or PC type and have those invoked with different hotkeys to create a PC or Ruler as needed.

Example file:
```json
{
    "types": [
        {
                "typeName": "NPC",
                "typeFolderNames": [ "People" ],
                "frontmatter": [
                    "species",
                    "born",
                    "ancestry",
                    "gender",
                    "died",
                    "home",
                    "homeRegion",
                    "origin",
                    "originRegion",
                    "affiliations"
                ],      
                "initialTags": [
                    "NPC/unsorted"
                ]            
        },
       {
                "typeName": "Item",
                "typeFolderNames": [ "Things" ],
                "frontmatter": [
                    "created",
                    "destroyed",
                    "magic",
                    "dbbLink"
                ],      
                "initialTags": [
                    ""
                ]            
        }

    ]

}
```

This also supports a custom map, in `taelgarConfig.json`, that maps from file type -> folder -> default tags. Currently this only supports the leaf folder name but may be enhanced in the future to include regex support.

### process-note-withprompts
This is indentical to process-note, except that it wil prompt for missing data. At the moment it only prompts for gender and born year, but more prompts are expected to be added with time.
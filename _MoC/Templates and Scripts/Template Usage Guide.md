# Templates Documentation

This file contains documentation for the usage of the templates within the templates folder. Currrently, there are three major complex templates for management of headers and metadata.

### generate-header
This template generates a header block based on the metadata within the frontmatter of the file. It creates a custom block for the entity types it is aware of. To ease export to HTML. the header block this template generates is mostly static. Currently the only dynamic pieces are the age and birth and death years of NPCs and the age, birth, death, and regnal years of Rules. These dynamic elements use dataview. In the future additional dynamic elements might be added.

Each dynamic element used by generate-header must also be implemented in convert_markdown.py in order to enable seemless export to HTML.

This template requires the `dViewPath` to be set in your `taelgarConfig.json`. 

### regenerate-header
This template is expected to be run on files with a type already defined. It will not modify or insert metadata and does not make use of the `metadata.json` or `taelgarConfig.json` files. The primary usage of this is to delete the header generated by generate-header and reinsert the generate-header template. This allows a quick refresh of a header after changing metadata.

This template will delete data from your file, and uses raw read/write APIs from the Obsidian Vault API. It is recommended that you save your file before running this in order to ensure that the template is always reading the newest data from disk.

The header is defined as the set of lines between the end of the YAML frontmatter and the first blank line.

This template makes no use of configuration. 

### process-note
This template is a generic processing template designed to process either an empty note, a partially completed note (either with minimal metadata or with no metadata), or a note with complete metadata and:

* Determine the note type, or if not possible, prompt for it
* Prompt for a name, if run in a file named Untitled. Note that this will detect name clashes and enforce a unique name for the file across the vault.
* Ensure that all expected metadata elements are present and insert missing ones, using folder-based default vaules if configured
* Insert or update the header block

This is intended to be run in new files and would be suitable to be auto-run for all new files. It depends on both the `taelgarConfig.json` file to determine default values for metadata elements and the shared `metadata.json` to determine the set of metadata elements and initial tags to insert in a file.

The processing flow is:
1. Determine the type of the file by matching on path or from the frontmatter
2. If the file type cannot be determined via path matching, prompt for a file type
3. Determine the name of the file, either from the filename, or if the filename is Untitled, by prompting
4. Find the default tags and metadata for the file type and insert into the frontmatter
5. Delete the header material and reinsert the header template. Note that if the file has no frontmatter when the template is run, the header is inserted before the full contents of the file and no deletion occurs

#### Configuration Rules

The configuration file has a single property, `types`, which is an array of type objects. Each type object has:
* A string type name, i.e. NPC, Item, Building
* An array of strings, frontmatter, which is a list of the frontmatter to insert for this type
* An array of strings, initial tags, which is a list of tags to set for this type if the type has no tags
* An array of strings, typeFolderNames, which is a list of regexes that will be applied to the full relative path of the file to auto-determine the type. Note that order matters, i.e. the code uses the first match. So if you have a match on People and one on PCs, make sure the PCs is listed first in the file as People is also in the PC 

Note that the JavaScript function used by the template allows for a parameter for setting the type, so instead of making complex regex it is also possible to just define a ruler or PC type and have those invoked with different hotkeys to create a PC or Ruler as needed.

Example file:
```json
{
    "types": [
        {
                "typeName": "NPC",
                "typeFolderNames": [ "People" ],
                "frontmatter": [
                    "species",
                    "born",
                    "ancestry",
                    "gender",
                    "died",                    
                    "affiliations"
                ],      
                "supportsWhereabouts": true,
                "initialTags": [
                    "NPC/unsorted"
                ]            
        },
       {
                "typeName": "Item",
                "typeFolderNames": [ "Things" ],
                "frontmatter": [
                    "created",
                    "destroyed",
                    "magic",
                    "dbbLink"
                ],      
                "initialTags": [
                    ""
                ]            
        }

    ]

}
```

This also supports a custom map, in `taelgarConfig.json`, that maps from file type -> folder -> default tags. Currently this only supports the leaf folder name but may be enhanced in the future to include regex support.

### process-note-withprompts
This is indentical to process-note, except that it wil prompt for missing data. At the moment it only prompts for gender and born year, but more prompts are expected to be added with time.

### Whereabouts Handling

Whereabouts provides a mechanism to define a sequence of locations for a specific item, person, etc and generate a location block for that thing in the header section.

It uses a YAML structure like:

```YAML
whereabouts:
     - { date: 1682-01-01, place: "Ainswick", region: Sembara}
     - { date: 1682-01-02, place: "Cleenseau", region: Sembara}
     - { date: 1701-05-02, place: "Taviose", region: Sembara, excursion: true}
```

Each record represents a location of a person at a specific time. The excursion flag indicates that this particular location is a trip away from a base, and is used in calcuation of the header (see below).

This YAML structure can be manually edited, but it is also updated via the process-note template as follows, if the metadata for the type defines a supportsWhereabouts boolean to true.

>[!Tip] 
>The dates must be ordered correctly in the YAML for the heading to work

* If the front matter contains an origin or originRegion, it is translated to a whereabouts line with a date of born-01-01, if born is set, or 0001-01-01 if not
* If the front matter contains a home or homeRegion, it is translated to a whereabouts line with a date of born-01-02, if born is set, or 0001-01-02 if not
* If the front matter contains a location or locationRegion, it is translated to a whereabouts line with a date of campaign-current-date from Fantasy Calendar

The home, homeRegion, origin, originRegion, location, and locationRegion elements are then deleted. 

>[!Tip]
>If you rerun the process-note template after setting a born date it will fixup any whereabouts that still have 0001-years

#### Generating Headers (OBSOLETE)
The whereabouts is turned into a header via the get_Whereabouts DataView view script. This generates between 0 and 4 headers:

* A "Based in" line using the last whereabout value before the current fantasy calendar date that is not an excursion 
* An "Originally from" line using the first whereabout value after or equal to the born date (or 1/1/1 if no born date)
* A "Current location" line using the last whereabout value before the current fantasy calendar date, even if it is an excursion
* A "Last known location" line using the last whereabout value before the current lastSeenByParty (or, if set, lastSeenByParty_campaignprefix) value

The code then excludes lines as follows:
* If the originally from line is the same as the based in line, it is not shown
* If the current location line is the same as the based in line, it is not shown
* If the last known location line is the same as either the based in line or the current location line, it is not shown. Also, if the lastSeenByParty value is not set, this line is never shown

The based in line only doesn't show if there are no whereabouts.